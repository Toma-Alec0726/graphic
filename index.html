<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>習字画像から「文字のみ」抽出ツール（ブラウザ版）</title>
<style>
  body { font-family: system-ui, -apple-system, Segoe UI, Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", Meiryo, sans-serif; margin: 16px; }
  header { margin-bottom: 12px; }
  .controls { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 12px; }
  .control { border: 1px solid #ddd; border-radius: 8px; padding: 10px; }
  .control label { font-size: 12px; color: #333; display:block; }
  .control input[type="range"] { width: 100%; }
  .row { display:flex; gap:12px; align-items:center; flex-wrap: wrap; }

  :root { --preview-width: 360px; }
  .preview { display:flex; gap:12px; align-items:flex-start; flex-wrap: wrap; }
  .preview .panel { flex: 1 1 auto; }
  .preview canvas { width: var(--preview-width); height: auto; background: #f4f4f4; border: 1px solid #ddd; border-radius: 8px; }

  button { padding: 8px 12px; font-size: 14px; }
  .note { font-size: 12px; color: #666; }
  .hidden { display:none; }
</style>
</head>
<body>
  <header>
    <h1>習字画像から「文字のみ」抽出ツール（ブラウザ版 v2）</h1>
    <p class="note">紙の皺や反射のムラを避けつつ、文字だけ抽出して黒一色（または濃淡保持）のPNGを生成。背景は透明/白を選択可。完全オフラインで動作。</p>
  </header>

  <div class="row">
    <input type="file" id="fileInput" accept="image/*" />
    <button id="processBtn" disabled>処理する</button>
    <button id="saveBtn" disabled>PNGを保存</button>
  </div>

  <div class="controls">
    <div class="control">
      <label>しきい値モード</label>
      <div>
        <label><input type="radio" name="thMode" id="thModeOtsu" checked> Otsu＋補正</label>
        <label><input type="radio" name="thMode" id="thModeFixed"> 固定しきい値</label>
      </div>
      <div id="otsuGroup">
        <label>Otsuしきい値補正: <span id="thOffsetVal">-10</span></label>
        <input type="range" id="thOffset" min="-100" max="100" step="1" value="-10" />
        <div class="note">負にすると厳しめ（空白を守る）。正にすると緩め（薄い墨も拾う）。</div>
      </div>
      <div id="fixedGroup" class="hidden">
        <label>固定しきい値（0〜255）: <span id="thFixedVal">40</span></label>
        <input type="range" id="thFixed" min="0" max="255" step="1" value="40" />
        <div class="note">**基準値 40** を初期値にしています。</div>
      </div>
    </div>

    <div class="control">
      <label>ぼかし半径（紙のムラ緩和）: <span id="blurVal">1.0</span></label>
      <input type="range" id="blurRadius" min="0" max="3" step="0.5" value="1.0" />
      <div class="note">強すぎると筆致が失われるので控えめ推奨。</div>
    </div>

    <div class="control">
      <label>極小黒点の除去（面積px）: <span id="areaVal">100</span></label>
      <input type="range" id="areaThreshold" min="0" max="400" step="10" value="100" />
      <div class="note">**基準値 100**。皺影の微小ノイズを削除。文字の細線が消えない範囲で調整。</div>
    </div>

    <div class="control">
      <label>形状整形（膨張→収縮）サイズ: <span id="morphVal">3</span></label>
      <input type="range" id="morphSize" min="0" max="7" step="1" value="3" />
      <div class="note">0でオフ。3〜5で軽く滑らかに。大きくすると隙間が埋まりやすくなります。</div>
    </div>

    <div class="control">
      <label><input type="checkbox" id="solidBlack" checked /> 黒一色に統一（RGB=0,0,0）</label>
      <div class="note">チェックを外すと元の濃淡を保持した透過PNGになります。</div>
    </div>

    <div class="control">
      <label><input type="checkbox" id="autoTrim" checked /> 自動トリミング（外接矩形）</label>
      <div class="note">出力PNGの余白を最小化します。</div>
    </div>

    <div class="control">
      <label><input type="checkbox" id="transparentBg" checked /> 背景を透明にする</label>
      <div class="note">チェックを外すと背景は白で不透明になります。</div>
    </div>

    <div class="control">
      <label>プレビュー幅（横並び用）: <span id="previewWidthVal">360</span>px</label>
      <input type="range" id="previewWidth" min="240" max="800" step="20" value="360" />
      <div class="note">横並びで見やすいサイズに調整できます（左右のキャンバスに適用）。</div>
    </div>
  </div>

  <h2>プレビュー</h2>
  <div class="preview">
    <div class="panel">
      <p>入力画像</p>
      <canvas id="srcCanvas"></canvas>
    </div>
    <div class="panel">
      <p>出力（PNGプレビュー）</p>
      <canvas id="outCanvas"></canvas>
    </div>
  </div>

<script>
/* ===== 要素参照 ===== */
const fileInput    = document.getElementById('fileInput');
const processBtn   = document.getElementById('processBtn');
const saveBtn      = document.getElementById('saveBtn');
const srcCanvas    = document.getElementById('srcCanvas');
const outCanvas    = document.getElementById('outCanvas');

const thModeOtsu   = document.getElementById('thModeOtsu');
const thModeFixed  = document.getElementById('thModeFixed');
const otsuGroup    = document.getElementById('otsuGroup');
const fixedGroup   = document.getElementById('fixedGroup');

const thOffset      = document.getElementById('thOffset');
const thFixed       = document.getElementById('thFixed');
const blurRadius    = document.getElementById('blurRadius');
const areaThreshold = document.getElementById('areaThreshold');
const morphSize     = document.getElementById('morphSize');
const autoTrim      = document.getElementById('autoTrim');
const solidBlack    = document.getElementById('solidBlack');
const transparentBg = document.getElementById('transparentBg');

const thOffsetVal = document.getElementById('thOffsetVal');
const thFixedVal  = document.getElementById('thFixedVal');
const blurVal     = document.getElementById('blurVal');
const areaVal     = document.getElementById('areaVal');
const morphVal    = document.getElementById('morphVal');

const previewWidth    = document.getElementById('previewWidth');
const previewWidthVal = document.getElementById('previewWidthVal');

/* ===== 状態 ===== */
let originalName = 'output';
let srcImageData = null;

/* ===== ラベル更新 ===== */
function updateLabels(){
  thOffsetVal.textContent = thOffset.value;
  thFixedVal.textContent  = thFixed.value;
  blurVal.textContent     = blurRadius.value;
  areaVal.textContent     = areaThreshold.value;
  morphVal.textContent    = morphSize.value;
}
['input','change'].forEach(ev=>{
  [thOffset, thFixed, blurRadius, areaThreshold, morphSize]
    .forEach(el=> el.addEventListener(ev, updateLabels));
});
updateLabels();

/* ===== モード切替 ===== */
function toggleThMode(){
  if (thModeOtsu.checked) {
    otsuGroup.classList.remove('hidden');
    fixedGroup.classList.add('hidden');
  } else {
    fixedGroup.classList.remove('hidden');
    otsuGroup.classList.add('hidden');
  }
}
thModeOtsu.addEventListener('change', toggleThMode);
thModeFixed.addEventListener('change', toggleThMode);
toggleThMode();

/* ===== プレビュー幅（横並び） ===== */
function setPreviewWidth(){
  previewWidthVal.textContent = previewWidth.value;
  document.documentElement.style.setProperty('--preview-width', previewWidth.value + 'px');
}
previewWidth.addEventListener('input', setPreviewWidth);
setPreviewWidth();

/* ===== 画像読み込み（統合） ===== */
fileInput.addEventListener('change', (e)=>{
  const file = e.target.files && e.target.files[0];
  if (!file) return;

  originalName = file.name.replace(/\.[^.]+$/, '') || 'output';
  const img = new Image();
  img.onload = ()=>{
    try {
      const sctx = srcCanvas.getContext('2d');
      srcCanvas.width  = img.naturalWidth;  srcCanvas.height = img.naturalHeight;
      outCanvas.width  = img.naturalWidth;  outCanvas.height = img.naturalHeight;

      sctx.clearRect(0,0,srcCanvas.width,srcCanvas.height);
      sctx.drawImage(img, 0, 0);
      srcImageData = sctx.getImageData(0,0,srcCanvas.width, srcCanvas.height);

      processBtn.disabled = false;
      saveBtn.disabled    = true;
    } catch (err) {
      console.error('画像初期化エラー', err);
      alert('画像の読み込みでエラーが発生しました。別の画像やブラウザでお試しください。');
      processBtn.disabled = true;
      saveBtn.disabled    = true;
    }
  };
  img.onerror = ()=>{
    alert('画像の読み込みに失敗しました。ファイル形式をご確認ください。');
  };
  img.src = URL.createObjectURL(file);
});

/* ===== 画像処理ユーティリティ ===== */
function toGrayscale(imageData){
  const {width, height, data} = imageData;
  const gray = new Uint8ClampedArray(width*height);
  for (let i=0, j=0; i<data.length; i+=4, j++){
    const r=data[i], g=data[i+1], b=data[i+2];
    gray[j] = Math.round(0.299*r + 0.587*g + 0.114*b);
  }
  return {width, height, data: gray};
}

function gaussianBlur3x3(gray){
  const {width:w, height:h, data:src} = gray;
  const dst = new Uint8ClampedArray(src.length);
  const tmp = new Float32Array(src.length);
  for(let y=0;y<h;y++){
    const base=y*w;
    for(let x=0;x<w;x++){
      const a = src[base + Math.max(x-1,0)];
      const b = src[base + x];
      const c = src[base + Math.min(x+1,w-1)];
      tmp[base + x] = (a + 2*b + c)/4.0;
    }
  }
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const a = tmp[Math.max(y-1,0)*w + x];
      const b = tmp[y*w + x];
      const c = tmp[Math.min(y+1,h-1)*w + x];
      dst[y*w + x] = Math.round((a + 2*b + c)/4.0);
    }
  }
  return {width:w, height:h, data: dst};
}

function otsuThreshold(gray){
  const {data} = gray; const N=data.length;
  const hist = new Array(256).fill(0);
  for(let i=0;i<N;i++) hist[data[i]]++;
  let total=N, sumTotal=0;
  for(let i=0;i<256;i++) sumTotal += i*hist[i];
  let weightBg=0, sumBg=0, maxBetween=0, threshold=127;
  for(let t=0;t<256;t++){
    weightBg += hist[t]; if(!weightBg) continue;
    const weightFg = total - weightBg; if(!weightFg) break;
    sumBg += t*hist[t];
    const meanBg = sumBg / weightBg;
    const meanFg = (sumTotal - sumBg) / weightFg;
    const between = weightBg * weightFg * (meanBg - meanFg)**2;
    if (between > maxBetween){ maxBetween=between; threshold=t; }
  }
  return threshold;
}

function binarize(gray, threshold){
  const {width:w, height:h, data} = gray;
  const out = new Uint8Array(data.length);
  const thr = Math.max(0, Math.min(255, threshold|0));
  for(let i=0;i<data.length;i++) out[i] = (data[i] <= thr) ? 1 : 0;
  return {width:w, height:h, data: out};
}

function removeSmallComponents(bin, areaThr){
  if (areaThr<=0) return bin;
  const {width:w, height:h, data} = bin;
  const visited = new Uint8Array(data.length);
  const neigh = [-1,-1,-1,0,-1,1,0,-1,0,1,1,-1,1,0,1,1];
  function idx(x,y){ return y*w + x; }
  const out = bin.data.slice();
  const qx = new Int32Array(w*h);
  const qy = new Int32Array(w*h);
  for(let y0=0;y0<h;y0++){
    for(let x0=0;x0<w;x0++){
      const i0 = idx(x0,y0);
      if(out[i0]===1 && visited[i0]===0){
        let head=0, tail=0; qx[tail]=x0; qy[tail]=y0; tail++;
        visited[i0]=1;
        const comp = [i0];
        while(head<tail){
          const x=qx[head], y=qy[head]; head++;
          for(let k=0;k<neigh.length;k+=2){
            const nx=x+neigh[k], ny=y+neigh[k+1];
            if(nx<0||ny<0||nx>=w||ny>=h) continue;
            const ii = idx(nx,ny);
            if(visited[ii]===0 && out[ii]===1){
              visited[ii]=1; qx[tail]=nx; qy[tail]=ny; tail++; comp.push(ii);
            }
          }
        }
        if (comp.length < areaThr) for(const ii of comp) out[ii]=0;
      }
    }
  }
  return {width:w, height:h, data: out};
}

function morphClose(bin, size){
  if (!size || size<1) return bin;
  const {width:w, height:h, data} = bin;
  const rad = Math.floor(size/2);
  const dil = new Uint8Array(data.length);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let v=0;
      for(let yy=y-rad; yy<=y+rad; yy++){
        for(let xx=x-rad; xx<=x+rad; xx++){
          if(xx<0||yy<0||xx>=w||yy>=h) continue;
          if(data[yy*w+xx]===1){ v=1; break; }
        }
        if(v===1) break;
      }
      dil[y*w+x]=v;
    }
  }
  const ero = new Uint8Array(data.length);
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      let v=1;
      for(let yy=y-rad; yy<=y+rad; yy++){
        for(let xx=x-rad; xx<=x+rad; xx++){
          if(xx<0||yy<0||xx>=w||yy>=h) continue;
          if(dil[yy*w+xx]===0){ v=0; break; }
        }
        if(v===0) break;
      }
      ero[y*w+x]=v;
    }
  }
  return {width:w, height:h, data: ero};
}

function composeRGBA(srcImageData, maskBin, solid, transparent){
  const {width:w, height:h} = maskBin;
  const out = new ImageData(w,h);
  const src = srcImageData.data;
  const dst = out.data;
  for(let i=0,j=0; i<dst.length; i+=4, j++){
    const m = maskBin.data[j];
    if (m===1){
      if (solid){ dst[i]=0; dst[i+1]=0; dst[i+2]=0; }
      else { dst[i]=src[i]; dst[i+1]=src[i+1]; dst[i+2]=src[i+2]; }
      dst[i+3]=255;
    } else {
      if (transparent){ dst[i]=0; dst[i+1]=0; dst[i+2]=0; dst[i+3]=0; }
      else { dst[i]=255; dst[i+1]=255; dst[i+2]=255; dst[i+3]=255; }
    }
  }
  return out;
}

function autoTrimImageData(imageData){
  const {width:w, height:h, data} = imageData;
  let top=h, left=w, bottom=-1, right=-1;
  for(let y=0;y<h;y++){
    for(let x=0;x<w;x++){
      const a = (y*w + x)*4 + 3;
      if (data[a]!==0){
        if(y<top) top=y; if(x<left) left=x;
        if(y>bottom) bottom=y; if(x>right) right=x;
      }
    }
  }
  if (bottom<0) return imageData;
  const tw = right-left+1, th = bottom-top+1;
  const out = new ImageData(tw, th);
  for(let y=0;y<th;y++){
    for(let x=0;x<tw;x++){
      const si = ((y+top)*w + (x+left))*4;
      const di = (y*tw + x)*4;
      out.data[di]   = data[si];
      out.data[di+1] = data[si+1];
      out.data[di+2] = data[si+2];
      out.data[di+3] = data[si+3];
    }
  }
  return out;
}

function drawToCanvas(canvas, imageData){
  canvas.width  = imageData.width;
  canvas.height = imageData.height;
  canvas.getContext('2d').putImageData(imageData, 0, 0);
}

/* ===== 処理ボタン ===== */
processBtn.addEventListener('click', ()=>{
  if (!srcImageData) return;
  try {
    let gray = toGrayscale(srcImageData);
    let gs = gray;
    const reps = Math.max(0, Math.round(parseFloat(blurRadius.value)));
    for (let i=0;i<reps;i++) gs = gaussianBlur3x3(gs);

    let threshold;
    if (thModeOtsu.checked) threshold = otsuThreshold(gs) + parseInt(thOffset.value,10);
    else threshold = parseInt(thFixed.value,10);

    let bin = binarize(gs, threshold);
    bin = removeSmallComponents(bin, parseInt(areaThreshold.value,10));
    bin = morphClose(bin, parseInt(morphSize.value,10));

    let out = composeRGBA(srcImageData, bin, solidBlack.checked, transparentBg.checked);
    if (autoTrim.checked) out = autoTrimImageData(out);

    drawToCanvas(outCanvas, out);
    saveBtn.disabled = false;
  } catch (err) {
    console.error('処理中のエラー', err);
    alert('画像処理でエラーが発生しました。パラメータを小さくするか、別画像でお試しください。');
    saveBtn.disabled = true;
  }
});

/* ===== 保存ボタン ===== */
saveBtn.addEventListener('click', ()=>{
  const link = document.createElement('a');
  link.download = originalName + '_ink_only.png';
  link.href = outCanvas.toDataURL('image/png');
  link.click();
});
</script>
</body>
</html>